"""Tools For Processing Database Output."""

from collections import Counter
import pandas as pd
import numpy as np

# Define Constants Used in HDAG
# These should be adjusted to change the resultant figure generated by the HDAG
PARENT_NODE_COLOR: str = "blue"
CHILD_NODE_COLOR: str = "red"
GRANDCHILD_NODE_COLOR: str = "green"
PARENT_NODE_Y: int = 10
CHILD_NODE_Y: int = 6
GRANDCHILD_NODE_Y: int = 2


def create_ingredient_list(ingredients: str) -> list[str]:
    """
    Convert Single Ingredient String into a list of ingredients.

    Input:
    -----
    ingredients: 'ingredient_list' column from Aiven database 'usda' table
        Note: Form of raw data '{ingredient 1, ingredient 2, ..., ingredient n}'

    Return:
    ------
    ingredients: List of the form [ingredient 1, ingredient 2, ..., ingredient n]

    """
    full_ingredient_row = (
        ingredients[0].replace("{", "").replace("}", "").replace('"', "")
    )

    return full_ingredient_row.split(",")


def count_ingredients(query_results: tuple[str]) -> Counter:
    """
    Count each ingredient in 'ingredients' columns of queried dataframe.

    Input:
    -----
    query_reults: Resultant dataframe from COUNT_QUERY_STRUCT

    Return:
    ------
    ingredient_counts: Counter object populated w/ list of all ingredients

    """
    all_ingredients = []
    for ingredients in query_results:
        all_ingredients += create_ingredient_list(ingredients)

    return Counter(all_ingredients)


class HDAG:
    """
    Data Structure representation of Heirarchically Directed Acyclic Graphs.

    Implementation:
    --------------
    # Create HDAG instance
    >>> example_HDAG = HDAG(example_dataframe, "parent_col", "child_col", "grandchild_col")

    """

    def __init__(
        self,
        data: pd.DataFrame,
        parent_name: str,
        child_name: str,
        grandchild_name: str,
    ) -> None:
        """

        HDAG requirements for instantiation.

        data              : Dataframe with columns matching parent_name, child_name, grandchild_name
        parent_name       : Column of data capable of grouping
        child_name        : Column of data that exists for every parent
        grandchild_name   : Column of data that exists for every child

        """
        # User defined methods
        self.data = data
        self.parent_name: str = parent_name
        self.child_name: str = child_name
        self.grandchild_name: str = grandchild_name
        # Populated Methods
        self.num_parents: int | None = None
        self.num_nodes: int | None = None
        self.hdag_nodes: dict = self.df_to_hdag_nodes()
        self.hdag: dict[str, list[int | float | str]] = self.populate_node_positions()

    def df_to_hdag_nodes(self) -> dict[str, dict[str, list[str]]]:
        """
        Convert a dataframe into a graph dictionary.

        The structure of the dictionary is of the following form:

            example_hdag_nodes = {

            parent_1 : {child_1_of_parent_1 : [grandchild_of_child_1_1, grandchild_of_child_1_2],
                        child_2_of_parent_1 : [grandchild_of_child_2]
                        },

            parent_2 : {child_1_of_parent_2 : [grandchild_of_child_1],
                        child_2_of_parent_2 : [grandchild_of_child_2_1, grandchild_of_child_2_2]
                        },
            .
            .
            .
                                }

        Where the parents are the group associated with the various children,
            and the grandchild are the values associated with each child.

        Return:
        ------
        hdag_nodes: Dict of the structure defined above as example_hdag_nodes

        """
        # Parents (Highest Level Nodes)

        # Initialize hdag with parent nodes
        hdag_nodes: dict[str, dict[str, list[str]]] = {
            parent: {} for parent in self.data[self.parent_name].unique()
        }

        # Populate hdag with children and grandchildren
        for parent, parent_group in self.data.groupby(self.parent_name):
            # Get all children/grandchildren for each parent
            for _, row in parent_group.iterrows():
                # If multiple grandchildren, append to grandchild list
                if row[self.child_name] in hdag_nodes[str(parent)]:
                    hdag_nodes[str(parent)][row[self.child_name]].append(
                        row[self.grandchild_name]
                    )
                # Else create new grandchild list
                else:
                    hdag_nodes[str(parent)][row[self.child_name]] = [
                        row[self.grandchild_name]
                    ]

        return hdag_nodes

    def populate_node_positions(
        self,
    ) -> dict[str, list[int | float | str]]:
        """
        Assign (x,y) positions to each node in the HDAG.

        Rules for position assignment:

        1) Parents have the highest y, followed by children, followed by grandchild

        2) If only one predecessor node (child to parent) or (grandchild to child) then assignment should be directly below

        3) If more than one predecessor node, then assignment should be slightly diagonal (linear spacing is employed)

        Return:
        ------
        hdag_positions : Dictionary containing node_index : (node_x_pos, node_y_pos, node_parent_name, node_color, node_x_ref, node_y_ref)

        """
        # Check/Assign num_parents
        if not self.num_parents:
            self.num_parents = len(self.hdag_nodes.keys())  # type: ignore[union-attr]

        # Check/Assign num_nodes
        if not self.num_nodes:
            self.num_nodes = (
                sum(
                    [
                        1  # BUG: CHECK ME PLEASE!
                        for parent in self.hdag_nodes
                        for child in parent
                        for grandchild in child
                    ]
                )
                + self.num_parents
            )  # type: ignore[union-attr, index, misc]

        hdag: dict[str, list[int | float | str]] = {
            "parent_x": [],
            "parent_y": [],
            "parent_text": [],
            "parent_color": [],
            "child_x": [],
            "child_y": [],
            "child_text": [],
            "child_color": [],
            "child_x_ref": [],
            "child_y_ref": [],
            "grandchild_x": [],
            "grandchild_y": [],
            "grandchild_text": [],
            "grandchild_color": [],
            "grandchild_x_ref": [],
            "grandchild_y_ref": [],
        }

        # Use parent node enumeration idx as x-positional reference for each parent group
        for idx, parent in enumerate(self.hdag_nodes):
            # Add parent values to hdag
            hdag_populator(
                hdag, "parent", idx, PARENT_NODE_Y, parent, PARENT_NODE_COLOR
            )

            # Get parent dictionary
            parent_node = self.hdag_nodes[parent]

            # Add positions for each child node
            for child in parent_node:
                # If only one child, stack directly below
                if len(parent_node.keys()) == 1:
                    # Add child values to hdag
                    hdag_populator(
                        hdag,
                        "child",
                        idx,
                        CHILD_NODE_Y,
                        child,
                        CHILD_NODE_COLOR,
                        node_x_ref=idx,
                        node_y_ref=PARENT_NODE_Y,
                    )

                    # Add grandchild node position
                    # If only one grandchild, stack directly below
                    if len(self.hdag_nodes[parent][child]) == 1:
                        # Add grandchild values to hdag
                        hdag_populator(
                            hdag,
                            "grandchild",
                            idx,
                            GRANDCHILD_NODE_Y,
                            self.hdag_nodes[parent][child][0],
                            GRANDCHILD_NODE_COLOR,
                            node_x_ref=idx,
                            node_y_ref=CHILD_NODE_Y,
                        )

                    # Else evenly space associated grandchild nodes
                    else:
                        # Add each node using linear spacing
                        grandchildren = self.hdag_nodes[parent][child]
                        num_grandchildren = len(grandchildren)
                        grandchild_spacing = np.linspace(
                            idx - 0.25, idx + 0.25, num_grandchildren
                        )
                        for grandchild, grandchild_x in zip(
                            grandchildren, grandchild_spacing
                        ):
                            # Add linearly spaced grandchild values to hdag
                            hdag_populator(
                                hdag,
                                "grandchild",
                                float(grandchild_x),
                                GRANDCHILD_NODE_Y,
                                grandchild,
                                GRANDCHILD_NODE_COLOR,
                                node_x_ref=idx,
                                node_y_ref=CHILD_NODE_Y,
                            )

        return hdag


def hdag_populator(
    hdag: dict[str, list[int | float | str]],
    node_type: str,
    node_x: int | float,
    node_y: int,
    node_text: str,
    node_color: str,
    node_x_ref: int | float = 0,
    node_y_ref: int = 0,
) -> None:
    """
    Populate hdag dictionary concisely.

    Input:
    -----
    hdag       : Datatype for HDAG.hdag being populated
    node_type  : Node type belonging to set {"parent", "child", "grandchild"}
    node_x     : X Position of node
    node_y     : Y Position of node
    node_text  : Text belonging to node
    node_color : Node Color for graphical display
    node_x_ref : Older Relative's X Position (Defaults to 0 for parents)
    node_y_ref : Older Relative's Y Position (Defaults to 0 for parents)
    """
    if node_type == "parent":
        hdag["parent_x"].append(node_x)
        hdag["parent_y"].append(node_y)
        hdag["parent_text"].append(node_text)
        hdag["parent_color"].append(node_color)

    else:
        hdag[f"{node_type}_x"].append(node_x)
        hdag[f"{node_type}_y"].append(node_y)
        hdag[f"{node_type}_text"].append(
            "<br>".join(node_text.split(","))
        )  # Add line breaks to display all ingredients when plotting
        hdag[f"{node_type}_color"].append(node_color)
        hdag[f"{node_type}_x_ref"].append(node_x_ref)
        hdag[f"{node_type}_y_ref"].append(node_y_ref)
